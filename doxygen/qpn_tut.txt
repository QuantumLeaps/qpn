/**
\page tutorial_page QP-nano Tutorial

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

This Tutorial presents an example project implemented entirely with the QP-nano
event-driven platform using UML state machines and the event-driven paradigm.
The example application is an interactive "Fly 'n' Shoot"-type game. My aim in
this section is to show the essential elements of the method in a real,
nontrivial program, but without getting bogged down in details, rules, and
exceptions. At this point, I am not trying to be complete or even precise,
although this example is meant to show a good design and the recommended
coding style. I don't assume that you know much about UML state machines, the
UML notation, or the event-driven programming. I will either briefly introduce
the concepts, as needed, or refer you to the the \ref PSiCC2 book for more
details. The example "Fly 'n' Shoot" game is based on the "Quickstart"
application provided in source code with the ARM Cortex-M3 LM3S811 evaluation kit
(see \ref F2s2 "Figure 2-2") from Luminary Micro
(http://www.luminarymicro.com). I was trying to make the "Fly 'n' Shoot"
example behave quite similarly to the original Luminary Micro "Quickstart"
application, so that you can directly compare the event-driven approach with
the traditional solution to essentially the same problem specification.

- \subpage installing
- \subpage lets_play
- \subpage main_function
- \subpage design
- \subpage active_objects
- \subpage events
- \subpage coding_hsm
- \subpage execution
- \subpage code_size
- \subpage comparison
- \subpage summary

\note The <A HREF="http://state-machine.com/downloads"><B>standard QP/C
distribution</B></A> contains two versions of the game. A <B>DOS version</B>
is provided for the standard Windows-based PC so that you don't need any
special embedded board to play the game and experiment with the code.
Also provided is an <B>embedded version</B> for the inexpensive ARM
Corterx-M3-based LM3S811 evaluation kit from Luminary Micro. Both the PC and
the ARM-Cortex versions use the exact <B>same</B> source code for all application
components and differ only in the Board Support Package (BSP).


Next: \ref installing

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page installing 1. Installing QP-nano and Building QP-nano Applications

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref tutorial_page \n
Next: \ref lets_play

QP-nano is distributed in a simple platform-independent ZIP file, or in a
self-extracting Windows executable. Either way, installing QP-nano requires
simply decompressing the provided archive into a directory of your choice
(e.g., \c &lt;qpn&gt; for QP-nano). The Section \ref files_page describes the
directories and files included in the standard QP-nano distribution.

Specifically to the "Fly 'n' Shoot" example, the companion code contains two
versions of the game. I provide a DOS version for the standard Windows-based
PC (see \ref F2s1 "Figure 2-1") so that you don't need any special embedded
board to play the game and experiment with the code.

\note I've chosen the legacy 16-bit DOS platform because it allows programming
a standard PC at the bare-metal level. Without leaving your desktop, you can
work with interrupts, directly manipulate CPU registers, and directly access
the I/O space. No other modern 32-bit development environment for the standard
PC allows this much so easily. The ubiquitous PC running under DOS (or a DOS
console within any variant of Windows) is as close as it gets to emulate
embedded software development on the commodity 80x86 hardware. Additionally,
you can use free, mature tools, such as the Open Watcom compiler.

I also provide an embedded version for the inexpensive ARM Corterx-M3-based
LM3S811 evaluation kit from Luminary Micro (see \ref F2s2 "Figure 2-2").
Both the PC and ARM-Cortex versions use the exact same source code for
all application components and differ only in the Board Support Package (BSP).

\note The standard QP-nano distribution contains pre-compiled examples (see
\ref files_page), so you can start experimenting with all examples without
building them. However, if you want to re-build the QP-nano examples, this
section provides the details.

\anchor F1s1
\image html Fig12.02.jpg "Figure 1-1 Building a QP-nano Application."

\ref F1s1 "Figure 1-1" shows the process of building a QP-nano application.
You merely need to add two QP-nano source files \c qepn.c and \c qfn.c to the
project and you need to instruct the compiler to search for the header files
in the \<qpn\>\\include\\ directory, typically through the <TT>-I</TT>
option.. (If you use QK-nano, you additionally need to add the \c qkn.c source
file.) The make script for building the "Fly 'n' Shoot" game for DOS with the
Open Watcom compiler is found in
\<qpn\>\\examples\\80x86\\watcom\\game\\make.bat. Similarly, the IAR EWARM
project file to build the game for ARM-Cortex with the IAR compiler is found in
\<qpn\>\\examples\\arm-cortex\\iar\\game-ev-lm3s811\\game.ewp.

Prev: \ref tutorial_page \n
Next: \ref lets_play

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page lets_play 2. Let's Play

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref installing \n
Next: \ref main_function

The following description of the "Fly 'n' Shoot" game serves the dual purpose
of explaining how to play the game and as the problem specification for the
purpose of designing and implementing the software later in this Tutorial. To
accomplish these two goals I need to be quite detailed, so please bear with
me.

Your objective in the game is to navigate a space ship through an endless
horizontal tunnel with mines. Any collision with the tunnel or the mine
destroys the ship. You can move the ship up and down with UP-arrow and
DOWN-arrow keys on the PC (see \ref F2s1 "Figure 2-1") or the potentiometer
wheel on the LM3S811 board (see \ref F2s2 "Figure 2-2"). You can also fire a
missile to destroy the mines in the tunnel by pressing the SPACE-bar on the PC
or the User button on the LM3S811 board. Score accumulates for survival (at
the rate of 30 points per second) and destroying the mines.

The game lasts for only one ship. The game starts in a demo mode, where the
tunnel walls scroll at the normal pace from right to left and the "Press
Button" text flashes in the middle of the screen. You need to generate the
"fire missile" event for the game to begin (press SPACE-bar on the PC and the
User Button on the LM3S811 board). You can have only one missile in flight at
a time, so trying to fire a missile while it is already flying has no effect.
Hitting the tunnel wall with the missile brings you no points, but you earn
extra points for destroying the mines.

The game has two types of mines with different behavior. In the original
Luminary "Quickstart" application both types of mines behave the same, but I
wanted to demonstrate how state machines can elegantly handle differently
behaving mines.

Mine type-1 is small, but can be destroyed by hitting any of its pixels with
the missile. You earn 25 points for destroying a mine type- Mine type-2 is
bigger, but is nastier in that the missile can destroy it only by hitting its
center, not any of the "tentacles". Of course, the ship is vulnerable to the
whole mine. You earn 45 points for destroying a mine type 2.

When your crash the ship, either by hitting a wall or a mine, the game ends
and displays the flashing "Game Over" text as well as your final score. After
5 seconds of flashing, the "Game Over" screen changes back to the demo screen,
where the game waits to be started again.

Additionally the application contains a screen saver because the OLED display
of the original LM3S811 board has burn-in characteristics similar to a CRT.
The screen saver only becomes active if 20 seconds elapse in the demo mode
without starting the game (i.e., the screen saver never appears during game
play). The screen saver is a simple random-pixel-type, rather than the "Game
of Life" algorithm used in the original Luminary "Quickstart" application.
I've decided to simplify this aspect of the implementation, because the more
elaborate pixel-mixing algorithm does not contribute any new or interesting
behavior. After a minute of running the screen saver, the display turns blank
and only a single random pixel shows on the screen. Again, this is a little
difference from the original "Quickstart" application, which instead blanks
the screen and starts flashing the User LED. I've changed this behavior
because I have a better purpose for the User LED (to visualize the activity of
the idle loop).

\section DOS Running the DOS Version

The "Fly 'n' Shoot" sample code for the DOS version (in C++) is located in
\c &lt;qpn&gt;\\examples\\80x86\\watcom\\game\\, directory, where \c
&lt;qpn&gt; stands for the installation directory you chose to install the
QP-nano software.

The compiled executable is provided, so you can run the game on any
Windows-based PC by simply double-clicking on the executable \c game.exe
located in the directory \c
&lt;qpn&gt;\\examples\\80x86\\watcom\\game\\dbg\\.

\anchor F2s1
\image html Fig1.01.jpg "Figure 2-1 The Fly 'n' Shoot game running in a DOS window under Windows XP."

The first screen you see is the game running in the demo mode with the text
"Push Button" flashing in the middle of the display. At the top of the display
you see a legend of keystrokes recognized by the application. You need to hit
the SPACE key to start playing the game. Please press the ESC key to cleanly
exit the application.

If you run "Fly 'n' Shoot" in a window under Microsoft Windows, the animation
effects in the game might appear a little jumpy, especially when compared to
the ARM-Cortex version of the same game. You can make the application execute
significantly smoother if you switch to the full-screen mode by pressing and
holding the Alt key and then pressing the Enter key. You go back to the window
mode by the same Alt-Enter key combination.

As you can see in \ref F2s1 "Figure 2-1", the DOS version uses simply the
standard VGA text mode to emulate the OLED display of the LM3S811 board. The
lower part of the DOS screen is used as a matrix of 80x16 character-wide
"pixels", which is a little less than the 96x16 pixels of the OLED display,
but is still good enough to play the game. I specifically avoid employing any
fancier graphics in this early example because I have a bigger fish to fry for
you than to worry about the irrelevant complexities of programming graphics.
My main goal is to make it easy for you to understand the event-driven code
and experiment with it.

To this end, I chose the <STRONG>Open Watcom</STRONG> toolset to build this
example as well as several other examples in this book. Open Watcom it is
available under a OSI-certified <STRONG>open source</STRONG> license that
permits free commercial and non-commercial use. You can download Open Watcom
C/C++ toolset for DOS from 
<a href="ftp://ftp.openwatcom.org/">ftp://ftp.openwatcom.org/</a>. Please
select the \c open-watcom-c-dos-1.8.exe installer. Ready to print documentation
in PDF format is also available from 
<a href="http://www.openwatcom.org/index.php/Manuals">
http://www.openwatcom.org/index.php/Manuals</a>.

The Open Watcom C/C++ toolset for DOS is distributed as a Windows installer. 
After you download the \c open-watcom-c-dos-1.8.exe file, please launch the
installer and follow the instructions it provides.

\note I strongly recommend that you install the Open Watcom toolset into the
directory \c C:\\tools\\watcom\\. That way, you will be able to use directly
the provided make scripts. If you choose to install Open Watcom into a different
location, you can still use the make scripts supplied with the QP distribution,
but you need to define the \c WATCOM environment variable. You should
<STRONG>not</STRONG> install Open Watcom in the standard "Prgram Files"
directory or any directory name with a space.

To experinment with the "Fly 'n' Shoot" game code you can use any code editor
to modify the source code. Then you re-build the application by means of the
supplied \c make.bat script, which is located in the directory \c
&lt;qpn&gt;\\examples\\80x86\\watcom\\game\\.

In the next section, I describe briefly how to run the embedded version of the
game. If you are not interested in the ARM-Cortex version, please feel free to
skip to the following Section \ref main_function, where I start explaining the
application code.


\section Cortex Running the ARM-Cortex Version

In contrast to the "Fly 'n' Shoot" version for DOS running in the ancient real
mode of the 80x86 processor, the exact same source code runs on one of the
most modern processors in the industry: the ARM-Cortex.

\anchor F2s2
\image html Fig1.02.jpg "Figure 2-2 The Fly 'n' Shoot game running on the ARM Cortex-M3 LM3S811 evaluation board."

The sample code for the ARM Cortex-M3 LM3S811 board is located in \c
&lt;qpc&gt;\\examples\\arm-cortex\\vanilla\\iar\\game-ev-lm3s811\\ directory,
where \c &lt;qpc&gt; stands for the root directory you chose to install the
accompanying software. The code for the ARM-Cortex kit has been compiled with
the 32KB-limited Kickstart edition of the <STRONG>IAR Embedded Workbench for
ARM</STRONG> (IAR EWARM) v 5.40, which is provided with the ARM Cortex-M3
EKI-LM3S811 kit. You can also download this software <STRONG>free</STRONG> of
charge directly from IAR Systems (http://www.iar.com), after filling out an
online registration.

The installation of IAR EWARM is quite straightforward, as the software comes
with the installation utility. You also need to install the USB drivers for
the hardware debugger built into the LM3S811 board, as described in the
documentation of the ARM Cortex-M3 LM3S811 kit.

\note I strongly recommend that you install the IAR EWARM toolset into the
directory \c C:\\tools\\iar\\arm_ks_5.40 That way, you will be able to use
directly the provided EWARM workspace files and make scripts.

Before you program the "Fly 'n' Shoot" game to the LM3S811 board, you might
want to play a little with the original "Quickstart" application that comes
pre-programmed with the LM3S811 kit.

To program the "Fly 'n' Shoot" game to the flash memory of the LM3S811 board,
you first connect the LM3S811 board to your PC with the USB cable provided in
the kit and make sure that the Power LED is on (see \ref F2s2 "Figure 2-2").
Next, you need to launch the IAR Embedded Workbench and open the workspace
game-ev-lm3s81eww located in \c
&lt;qpn&gt;\\examples\\arm-cortex\\iar\\game-ev-lm3s811\\ directory. At this
point your screen should look similar to the screenshot shown in \ref F2s3
"Figure 2-3". The game-ev-lm3s811 project is set up to use the LMI FTDI
debugger, which is the piece of hardware integrated on the LM3S811 board (see
\ref F2s2 "Figure 2-2"). You can verify this setup by opening the "Options"
dialog box via the Project->Options menu. Within the "Options" dialog box, you
need to select the Debugger category in the panel on the left. While you are
at it, you could also verify that the flash loading is enabled by selecting
the "Download" tab. The checked "Use flash loader(s)" checkbox means that the
flash loader application provided by IAR will be first loaded to the RAM of
the MCU, and this application will program the flash with the image of your
application. To start the flash programming process, select the Project->Debug
menu, or simply click on the Debug button (see \ref F2s3 "Figure 2-3") in the
toolbar. The IAR Workbench should respond by showing the flash programming
progress bar for several seconds, as shown in \ref F2s3 "Figure 2-3". Once the
flash programming completes, the IAR EWARM switches to the IAR C-Spy debugger
and the program should stop at the entry to main(). You can start playing the
game either by hitting the "Go" button in the debugger, or you can close the
debugger and reset the board by pressing the Reset button. Either way, "Fly
'n' Shoot" game is now permanently programmed into the LM3S811 board and will
start automatically upon every power up.

\anchor F2s3
\image html Fig1.03.jpg "Figure 2-3 Loading the Fly 'n' Shoot game into the flash of LM3S811 MCU with IAR EWARM IDE"

The IAR Embedded Workbench environment allows you to experiment with the "Fly
'n' Shoot" code very easily. You can edit the files and recompile the
application at a click of a button (F7). The only caveat is that the first
time after the installation of the IAR toolset you need to build the Luminary
Micro driver library for the LM3S811 MCU from the sources. You accomplish this
by loading the workspace ek-lm3s81eww located in the directory
\c &lt;IAR-EWARM&gt;\\ARM\\examples\\Luminary\\Cortex-M3\\boards\\ek-lm3s811,
where &lt;IAR-EWARM&gt; stands for the directory name where you've installed
the IAR toolset. In the ev-lm3s81eww workspace, you select the "driverlib -
Debug" project from the drop-down list at the top of the Workspace panel, and
then press F7 to build the library.

Prev: \ref installing \n
Next: \ref main_function

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page main_function 3. The main() Function and the qpn_port.h Header File

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref lets_play \n
Next: \ref design

Perhaps the best place to start the explanation of the "Fly 'n' Shoot"
application code is the main() function, located in the file \c main.c. Unless
indicated otherwise in this Tutorial, you can browse the code either in the
DOS version, or the ARM-Cortex version, because the application source code is
identical in both.

\section main_function The main() Function

\ref L3s1 "Listing 3-1" shows the \c main.c source file for the
“Fly ‘n’ Shoot” application, which contains the \c main() function along with
some important data structures required by QP-nano.

\note To explain code listings, I place numbers in parentheses at the
interesting lines in the left margin of the listing. I then use these labels
in the left margin of the explanation section that immediately follows the
listing. Occasionally, to unambiguously refer to a line of a particular
listing from sections of text other than the explanation section, I use the
full reference consisting of the listing number followed by the label. For
example, \ref L3s1 "Listing 3-1"(21) refers to the label (21) in
\ref L3s1 "Listing 3-1"

\anchor L3s1
<STRONG>Listing 3-1 The file main.c of the "Fly 'n' Shoot" game application.
</STRONG>
\code
 (1) #include "qpn_port.h"                                       /* QP-nano port */
 (2) #include "bsp.h"                             /* Board Support Package (BSP) */
 (3) #include "game.h"                                  /* application interface */

     /*..........................................................................*/
 (4) static QEvent l_tunnelQueue[GAME_MINES_MAX + 4];
 (5) static QEvent l_shipQueue[2];
 (6) static QEvent l_missileQueue[2];

     /* QF_active[] array defines all active object control blocks --------------*/
 (7) QActiveCB const Q_ROM Q_ROM_VAR QF_active[] = {
 (8)     { (QActive *)0,           (QEvent *)0,    0                     },
 (9)     { (QActive *)&AO_tunnel,  l_tunnelQueue,  Q_DIM(l_tunnelQueue)  },
(10)     { (QActive *)&AO_ship,    l_shipQueue,    Q_DIM(l_shipQueue)    },
(11)     { (QActive *)&AO_missile, l_missileQueue, Q_DIM(l_missileQueue) }
     };

     /* make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h */
(12) Q_ASSERT_COMPILE(QF_MAX_ACTIVE == Q_DIM(QF_active) - 1);

     /*..........................................................................*/
     void main (void) {
(13)     Tunnel_ctor ();
(14)     Ship_ctor   ();
(15)     Missile_ctor(GAME_MISSILE_SPEED_X);

(16)     BSP_init();                                     /* initialize the board */

(17)     QF_run();                                /* transfer control to QF-nano */
     }
\endcode

\li (1) Every application C-file that uses QP-nano must include the \c
qpn_port.h header file. This header file contains the specific adaptation of
QP-nano to the given processor and compiler, which is called a port. The QP
port is typically located in the application directory.

\li (2) The \c bsp.h header file contains the interface to the Board Support
Package and is located in the application directory.

\li (3) The \c game.h header file contains the declarations of events and
other facilities shared among the components of the "Fly 'n' Shoot" game. This
header file is located in the application directory.

\li (4-6) The application must provide storage for the event queues of all
active objects used in the application. In QP-nano the storage is provided at
compile time through the statically allocated arrays of events. Events are
represented as instances of the QEvent structure declared in the
\c \<qpn\>\\include\\qepn.h header file, included from \c qpn_port.h. Each
event queue of an active object can have a different length and you need to
decide this length based on your knowledge of the application. Please refer to
Chapters 6 and 7 in \ref PSiCC2 for the discussion of sizing event queues.

\li (7) Every QP-nano application must provide the constant array
\c QF_active[], which defines all active object control blocks in the
application. The control block \c QActiveCB structure groups together: (1) the
pointer to the corresponding active object instance, (2) the pointer to the
event queue buffer of the active object, and (3) the length of the queue
buffer.

In QP-nano, I use every opportunity to place data in ROM rather than in the
precious RAM. The QActiveCB structure contains data elements known at compile
time, so that these elements can be placed in ROMas opposed to placing them in
the active object structure (RAM). That way, I save anywhere from 10 to 80
bytes of RAM, depending on the number of active objects and the pointer size
of the target CPU. The Q_ROM macro is necessary on some CPU architecture to
enforce placement of constant objects, such as the QF_active[] array, in ROM.
On Harvard architecture CPUs (such as 8051 or AVR), the code and data spaces
are separate and are accessed through different CPU instructions. The const
keyword is not sufficient to place data in ROM, and various compilers often
provide specific extended keywords to designate the code space for placing
constant data, such as the "__code" extended keyword in the IAR 8051 compiler.
The macro Q_ROM hides such non-standard extensions. If you don't define Q_ROM
in qepn_port.h, it will be defined to nothing in the qepn.h
platform-independent header file. The Q_ROM_VAR macro defines the
compiler-specific directive for accessing a constant object in ROM. Many
compilers for 8-bit MCUs provide different size pointers for accessing objects
in various memories. Constant objects allocated in ROM often mandate the use
of specific-size pointers (e.g., far pointers) to get access to ROM objects.
The macro Q_ROM_VAR specifies the kind of the pointer to be used to access the
ROM objects. An example of valid Q_ROM_VAR macro definition is: __far
(Freescale HC(S)08 compiler).

\li (8) The first entry (\c QF_active[0]) corresponds to active object
priority of zero, which is reserved for the idle task and cannot be used for
any active object.

\li (9-11) The \c QF_active[] entries starting from one define the active
object control blocks in the order of their relative priorities. The maximum
number of active objects in QP-nano cannot exceed 8.

\note The order or the active object control blocks in the \c QF_active[]
array defines the priorities of active objects. This is the only place in the
code where you assign active object priorities.

\li (12) This compile-time assertion (see Chapter 6 in \ref PSiCC2) ensures
that the dimension of the QF_active[] array matches the number of active
objects #QF_MAX_ACTIVE defined in the \c qpn_port.h header file.

In QP-nano, #QF_MAX_ACTIVE denotes the exact number of active objects used in
the application, as opposed to the full-version QP, where #QF_MAX_ACTIVE
denotes just the configurable maximum number of active objects.

\note All active objects in QP-nano must be defined at compile time. This
means that all active objects exist from the beginning and cannot be started
(or stopped) later, as it is possible in the full-version QP.

The macro #QF_MAX_ACTIVE must be defined in qpn_port.h header file, because
QP-nano uses the macro to optimize the internal algorithms based on the number
of active objects. The compile-time assertion in line (12) makes sure that the
configured number of active objects indeed matches exactly the number of
active object control blocks defined in the \c QF_active[] array.

\li (13-15) The \c main() function must first explicitly calls all active
object constructors.

\li (16) The board support package (BSP) is initialized.

\li (17) At this point, you have initialized all components and have provided
to the QF-nano framework all the information it needs to manage your
application. The last thing you must do is to call the function \c QF_run() to
pass the control to the QF-nano framework.

Overall, the application startup is much simpler in QP-nano than in
full-version QP. Neither event pools, nor publish-subscribe lists are
supported, so you don't need to initialize them. You also don't start active
objects explicitly. The QF-nano framework starts all active objects defined in
the \c QF_active[] array automatically just after it gets control in
\c QF_run().


\section qpn_porth_h The qpn_port.h header file

The \c qpn_port.h header file defines the QP-nano port and all configuration
parameters for the particular application. Unlike in the full-version QP,
QP-nano ports are typically defined at the application level. Typically also,
the whole QP-nano port consists of just the qpn_port.h header file.
\ref L3s2 "Listing 3-2" shows the complete \c qpn_port.h file for the DOS
version of the “Fly ‘n’ Shoot” game.

\anchor L3s2
<STRONG>Listing 3-2 The qpn_port.h header file for the “Fly ‘n’ Shoot” game.
</STRONG>
\code
     #ifndef qpn_port_h
     #define qpn_port_h

 (1) #define Q_PARAM_SIZE            4
 (2) #define QF_TIMEEVT_CTR_SIZE     2
 (3) #define Q_NFSM

     /* maximum # active objects--must match EXACTLY the QF_active[] definition  */
 (4) #define QF_MAX_ACTIVE           3

                                      /* interrupt locking policy for task level */
 (5) #define QF_INT_LOCK()           _disable()
 (6) #define QF_INT_UNLOCK()         _enable()

 (7) #include <stdint.h>           /* Exact-width types (WG14/N843 C99 Standard) */
     #include <i86.h>                                /* for _disable()/_enable() */

 (8) #include "qepn.h"              /* QEP-nano platform-independent header file */
 (9) #include "qfn.h"                /* QF-nano platform-independent header file */

     #endif                                                        /* qpn_port_h */
\endcode


\li (1) The macro #Q_PARAM_SIZE defines the size (in bytes) of the scalar
event parameter. The allowed values are 0 (no parameter), 1, 2, or 4 bytes. If
you don't define this macro in qpn_port.h, the default of 0 (no parameter)
will be assumed.

\li (2) The macro #QF_TIMEEVT_CTR_SIZE defines the size (in bytes) of the time
event down-counter. The allowed values are 0 (no time events), 1, 2, or 4
bytes. If you don't define this macro in qpn_port.h, the default of 0 (no time
events) will be assumed.

\li (3) Defining the macro #Q_NFSM eliminates the code for the simple
non-hierarchical FSMs.

\li (4) You must define the QF_MAX_ACTIVE macro as the exact number of active
objects used in the application. The provided value must be between 1 and 8
and must be consistent with the definition of the \c QF_active[] array (see
\ref L3s1 "Listing 3-1"(12)).

\li (5-6) The macros #QF_INT_LOCK()/#QF_INT_UNLOCK() define the task-level
interrupt locking policy for QP-nano. I discuss QP-nano critical section in
Chapter 12 of \ref PSiCC2.

\li (7) Just like the full-version QP, QP-nano uses a subset of the
C99-standard exact-with integer types. The Open Watcom compiler provides
the \c \<stdint.h\> header file, so I'm using it here. If you work with 
a pre-standard compiler, you can typedef the six exact-width integer types
used in QP (uint8_t, int8_t, uint16_t, int16_t, uint32_t, and int32_t).
which I'm using here, is a pre-standard compiler and does not provide 
\li (8) The \c qpn_port.h must include the QEP-nano event processor interface
\c qepn.h.

\li (9) \c The qpn_port.h must include the QF-nano real-time framework
interface \c qfn.h.

\note The \c qpn_port.h header file in \ref L3s2 "Listing 3-2" implicitly
configures QP-nano to use the built-in cooperative "vanilla" kernel. The other
alternative, which is the preemptive QK-nano kernel, is configured
automatically when you include the \c qkn.h QK-nano interface in the
\c qpn_port.h header file.


Prev: \ref lets_play \n
Next: \ref design

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page design 4. Designing an Event-Driven Application

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref main_function \n
Next: \ref active_objects

To proceed further with the explanation of the "Fly 'n' Shoot" application, I
need to step up to the design level. At this point I need to explain how the
application has been decomposed into the active objects, and how these objects
exchange events to collectively deliver the functionality of the "Fly 'n'
Shoot" game.

In general, the decomposition of a problem into active objects is
not trivial. As usual in any decomposition, your goal is to achieve possibly
loose coupling among the active object components (ideally no sharing of any
resources), and you also strive for minimizing the communication in terms of
the frequency and size of exchanged events.

In the case of the "Fly 'n' Shoot" game, I need first to identify all objects
with reactive behavior (i.e. with a state machine). I applied the simplest
object-oriented technique of identifying objects, which is to pick the
frequently used nouns in the problem specification. From Section \ref
lets_play, I identified Ship, Missile, Mines, and Tunnel. However, not every
state machine in the system needs to be an active object (with a separate task
context, an event queue, and a unique priority level), and merging them is a
valid option when performance or space is needed. As an example of this idea,
I ended up merging the Mines into the Tunnel active object, whereas I
preserved the Mines as independent state machine components of the Tunnel
active object. By doing so I applied the "Orthogonal Component" design pattern
described in Chapter 5 of \ref PSiCC2.

The next step in the event-driven application design is assigning
responsibilities and resources to the identified active objects. The general
design strategy for avoiding sharing of resources is to encapsulate each
resource inside a dedicated active object and to let that object manage the
resource for the rest of the application. That way, instead of sharing the
resource directly, the rest of the application shares the dedicated active
object via events.

So, for example, I decided to put the Tunnel active object in charge of the
display. Other active objects and state machine components, such as Ship,
Missile and Mines, don't draw on the display directly, but rather send events
to the Tunnel object with the request to render the Ship, Missile, or Mine
bitmaps at the provided (x, y) coordinates of the display.

With some understanding of the responsibilities and resource allocations to
active object I can move on to devising the various scenarios of event
exchanges among the objects. Perhaps the best instrument to aid the thinking
process at this stage is the UML sequence diagram, such as the diagram
depicted in \ref F4s1 "Figure 4-1". This particular sequence diagram shows the
most common event exchange scenarios in the "Fly 'n' Shoot" game (the primary
use cases, if you will). The explanation section immediately following the
diagram illuminates the interesting points.

\note A UML sequence diagram like \ref F4s1 "Figure 4-1" has two dimensions.
Horizontally arranged boxes represent the various objects participating in the
scenario whereas heavy boarders indicate active objects. As usual in the UML,
the object name in underlined. Time flows down the page along the vertical
dashed lines descending from the objects. Events are represented as horizontal
arrows originating from the sending object and terminating at the receiving
object. Optionally, thin rectangles around instance lines indicate focus of
control.

\anchor F4s1
\image html Fig1.04.jpg "Figure 4-1 The sequence diagram of the Fly 'n' Shoot game."

\li (1) The \c TIME_TICK is the most important event in the game. This event is
generated by the QF framework from the system time tick interrupt at a rate of
30 times per second, which is needed to drive a smooth animation of the
display. Because the \c TIME_TICK event is of interest to virtually all
objects in the application, it is published by the framework to all active
objects. (The publish-subscribe event delivery in QF is described in Chapter 6
of \ref PSiCC2.)

\li (2) Upon reception of the \c TIME_TICK event, the Ship object advances its
position by one step and posts the event <TT>SHIP_IMG(x, y, bmp)</TT> to the
Tunnel object. The SHIP_IMG event has parameters x and y, which are the
coordinates of the Ship on the display, as well as the bitmap number bmp to
draw at these coordinates.

\li (3) The Missile object is not in flight yet, so it simply ignores the
\c TIME_TICK event this time.

\li (4) The Tunnel object performs the heaviest lifting for the \c TIME_TICK
event. First, Tunnel redraws the entire display from the current frame buffer.
This action performed 30 times per second provides the illusion of animation
of the display. Next, the Tunnel clears the frame buffer and starts filling it
up again for the next time frame. The Tunnel advances the tunnel walls by one
step and copies the walls to the frame buffer. The Tunnel also dispatches the
\c TIME_TICK event to all its Mine state machine components.

\li (5) Each Mine advances its position by one step and posts the <TT>MINE_IMG(x,
y, bmp)</TT> event to the Tunnel to render the appropriate Mine bitmap at the
position <TT>(x, y)</TT> in the current frame buffer. Mines of type 1 send the
bitmap number MINE1_BMP, while mines of type 2 send \c MINE2_BMP.

\li (6) Upon reception of the <TT>SHIP_IMG(x, y, bmp)</TT> event from the Ship,
the Tunnel object renders the specified bitmap in the frame buffer and checks
for any collision between the ship bitmap and the tunnel walls. Tunnel also
dispatches the original <TT>SHIP_IMG(x, y, bmp)</TT> event to all active
Mines.

\li (7) Each Mine determines if the Ship is in collision with that Mine.

\li (8) The \c PLAYER_TRIGGER event is generated when the Player reliably presses
the button (button press is debounced). This event is published by the QF
framework and is delivered to the Ship and Tunnel objects, which both
subscribe to the \c PLAYER_TRIGGER event.

\li (9) Ship generates the <TT>MISSILE_FIRE(x, y)</TT> event to the Missile
object. The parameters of this event are the current <TT>(x, y)</TT>
coordinates of the Ship, which are the starting point for the Missile.

\li (10) Tunnel receives the published \c PLAYER_TRIGGER event as well because
Tunnel occasionally needs to start the game or terminate the screen saver mode
based upon this stimulus.

\li (11) Missile reacts to the <TT>MISSILE_FIRE(x, y)</TT> event by starting to
fly, whereas it sets its initial position from the <TT>(x, y)</TT> event
parameters delivered from the Ship.

\li (12) This time around, the \c TIME_TICK event arrives while Missile is in
flight. Missile posts the <TT>MISSILE_IMG(x, y, bmp)</TT> event to the Table.

\li (13) Table renders the Missile bitmap in the current frame buffer and
dispatches the <TT>MISSILE_IMG(x, y, bmp)</TT> event to all the Mines to let
the Mines test for the collision with the Missile. This determination depends
on the type of the Mine. In this scenario a particular Mine[n] object detects
a hit and posts the <TT>HIT_MINE(score)</TT> event to the Missile. The Mine
provides the score earned for destroying this particular mine as the parameter
of this event.

\li (14) Missile handles the <TT>HIT_MINE(score)</TT> event by becoming
immediately ready to launch again and lets the Mine do the exploding. As I
decided to make the Ship responsible for the scorekeeping, the Missile also
generates the <TT>DESTROYED_MINE(score)</TT> event to the Ship, to report the
score for destroying the Mine.

\li (15) Upon reception of the <TT>DESTROYED_MINE(score)</TT> event, the Ship
updates the score reported by the Missile.

\li (16) The Ship object handles the <TT>PLAYER_SHIP_MOVE(x, y)</TT> event by
updating its position from the event parameters.

\li (17) When the Tunnel object handles the <TT>SHIP_IMG(x, y, bmp_id)</TT> event
next time around, it detects a collision between the Ship and the tunnel wall.
In that case it posts the event \c HIT_WALL to the Ship.

\li (18) The Ship responds to the \c HIT_WALL event by transitioning to the
"exploding" state.

Even though the sequence diagram in \ref F4s1 "Figure 4-1" shows merely some
selected scenarios of the "Fly 'n' Shoot" game, I hope that the explanations
give you a big picture of how the application works. More importantly, you
should start getting the general idea about the thinking process that goes
into designing an event-driven system with active objects and events.

Prev: \ref main_function \n
Next: \ref active_objects

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page active_objects 5. Elaborating State Machines of Active Objects

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref design \n
Next: \ref events

I hope that the analysis of the sequence diagram in \ref F4s1 "Figure 4-1" makes
it clear that actions performed by an active object depend as much on the
events it receives, as on the internal mode of the object. For example, the
Missile active object handles the \c TIME_TICK event very differently when the
Missile is in flight (\ref F4s1 "Figure 4-1"(12)) compared to the time when it is
not (\ref F4s1 "Figure 4-1"(3)). The best known mechanism of handling such modal
behavior is through state machines because a state machine makes the behavior
explicitly dependent on both the event and the state of an object. In Chapter
2 of \ref PSiCC2 I introduce UML state machine concepts more thoroughly. In
this section, I give a cursory explanation of the state machines associated
with each object in the "Fly 'n' Shoot" game.

\section missile 5.1 The Missile Active Object

I start with the Missile state machine shown in \ref F5s1 "Figure 5-1", because it
turns out to be the simplest one. The explanation section immediately
following the diagram illuminates the interesting points.

\note A UML state diagram like \ref F5s1 "Figure 5-1" preserves the general form
of the traditional state transition diagrams, where states are represented as
nodes and transitions as arcs connecting the nodes. In the UML notation the
state nodes are represented as rectangles with rounded corners. The name of
the state appears in bold type in the name compartment at the top of the
state. Optionally, right below the name, a state can have an internal
transition compartment separated from the name by a horizontal line. The
internal transition compartment can contain entry actions (actions following
the reserved symbol "entry"), exit actions (actions following the reserved
symbol "exit"), and other internal transitions (e.g., those triggered by
\c TIME_TICK in \ref F5s1 "Figure 5-1"(3)). State transitions are represented as
arrows originating at the boundary of the source state and pointing to the
boundary of the target state. At a minimum, a transition must be labeled with
the triggering event. Optionally, the trigger can be followed by event
parameters, a guard, and a list of actions.

\anchor F5s1
\image html Fig1.05.jpg "Figure 5-1 Missile state machine diagram."

\li (1) The state transition originating at the black ball is called the initial
transition. Such transition designates the first active state after the state
machine object is created. An initial transition can have associated actions,
which in the UML notation are enlisted after the forward slash "/". In this
particular case, the Missile state machine starts in the "armed" state and the
actions executed upon the initialization consist of subscribing to the event
\c TIME_TICK. Subscribing to an event means that the framework will deliver
the specified event to the Missile active object every time the event is
published to the framework. Chapter 7 of \ref PSiCC2 describes the
implementation of the publish-subscribe event delivery in QF.

\li (2) The arrow labeled with the <TT>MISSILE_FIRE(x, y)</TT> event denotes a
state transition, that is, change of state from "armed" to "flying". The
<TT>MISSILE_FIRE(x, y)</TT> event is generated by the Ship object when the
Player triggers the Missile (see the sequence diagram in \ref F4s1 "Figure 4-1").
In the \c MISSILE_FIRE event, Ship provides Missile with the initial
coordinates in the event parameters <TT>(x, y)</TT>.

\note The UML intentionally does not specify the notation for actions. In
practice, the actions are often written in the programming language used for
coding the particular state machine. In all state diagrams in this book, I
assume the C programming language. Furthermore, in the C expressions I refer
to the data members associated with the state machine object through the
<TT>me-></TT> prefix and to the event parameters through the <TT>e-></TT>
prefix. For example, the action <TT>me->x = e->x;</TT> means that the internal
data member \c x of the Missile active object is assigned the value of the
event parameter \c x.

\li (3) The event name \c TIME_TICK enlisted in the compartment below the state
name denotes an internal transition. Internal transitions are simple reactions
to events performed without a change of state. An internal transition, as well
as a regular transition, can have a guard condition, enclosed in square
brackets. Guard condition is a Boolean expression evaluated at runtime. If the
guard evaluates to TRUE, the transition is taken. Otherwise, the transition is
not taken and no actions enlisted after the forward slash "/" are executed. In
this particular case, the guard condition checks whether the x-coordinate
propagated by the Missile speed is still visible on the screen. If so, the
actions are executed. These actions include propagation of the Missile
position by one step and posting the \c MISSILE_IMG event with the current
Missile position and the \c MISSILE_BMP bitmap number to the Tunnel active
object. Direct event posting to an active object is accomplished by the QF
function QActive_postFIFO(), which I discuss in Chapter 7 of \ref PSiCC2.

\li (4) The same event \c TIME_TICK with the <TT>[else]</TT> guard denotes a
regular state transition with the guard condition complementary to the other
occurrence of the \c TIME_TICK event in the same state. In this case, the
\c TIME_TICK transition to "armed" is taken if the Missile object flies out of
the screen.

\li (5) The event <TT>HIT_MINE(score)</TT> triggers another transition to the
"armed" state. The action associated with this transition posts the
\c DESTROYED_MINE event with the parameter e->score to the Ship object, to
report destroying the mine.

\li (6) The event \c HIT_WALL triggers a transition to the "exploding" state, with
the purpose of animating the explosion bitmaps on the display.

\li (7) The label "entry" denotes the entry action to be executed unconditionally
upon the entry to the "exploding" state. This action consists of clearing
explosion counter (<TT>me->exp_ctr</TT>) member of the Missile object.

\li (8) The \c TIME_TICK internal transition is guarded by the condition that the
explosion does not scroll off the screen, and that the explosion counter is
lower than 16. The actions executed include propagation of the explosion
position and posting the \c EXPLOSION_IMG event to the Tunnel active object.
Please note that the bitmap of the explosion changes as the explosion counter
gets bigger.

\li (6) The \c TIME_TICK regular transition with the complementary guard changes
the state back to the "armed" state. This transition is taken after the
animation of the explosion completes.

\section ship 5.2 The Ship Active Object

The state machine of the Ship active object is shown in \ref F5s2 "Figure 5-2".
This state machine introduces the profound concept of hierarchical state
nesting. The power of state nesting derives from the fact that it is designed
to eliminate repetitions that otherwise would have to occur.

One of the main responsibilities of the Ship active object is to maintain the
current position of the Ship. On the original LM3S811 board, this position is
determined by the potentiometer wheel (see \ref F2s2 "Figure 2-2"). The
<TT>PLAYER_SHIP_MOVE(x, y)</TT> event is generated whenever the wheel position
changes, as shown in the sequence diagram (\ref F4s1 "Figure 4-1"). The Ship
object must always keep track of the wheel position, which means that all
states of the Ship state machine must handle the <TT>PLAYER_SHIP_MOVE(x,
y)</TT> event.

In the traditional finite state machine (FSM) formalism, you would need to
repeat the Ship position update from the <TT>PLAYER_SHIP_MOVE(x, y)</TT> event
in every state. But such repetitions would bloat the state machine and, more
importantly, would represent multiple points of maintenance both in the
diagram and the code. Such repetitions go against the DRY principle (Don't
Repeat Yourself), which is vital for flexible and maintainable code.

Hierarchical state nesting remedies the problem. Consider the state "active"
that surrounds all other states in \ref F5s2 "Figure 5-2". The high-level "active"
state is called the superstate and is abstract in that the state machine
cannot be in this state directly, but only in one of the states nested within,
which are called the substates of "active". The UML semantics associated with
state nesting prescribes that any event is first handled in the context of the
currently active substate. If the substate cannot handle the event, the state
machine attempts to handle the event in the context of the next-level
superstate. Of course, state nesting in UML is not limited to just one level
and the simple rule of processing events applies recursively to any level of
nesting.

Specifically to the Ship state machine diagram shown in \ref F5s2 "Figure 5-2",
suppose that the event <TT>PLAYER_SHIP_MOVE(x, y)</TT> arrives when the state
machine is in the "parked" state. The "parked" state does not handle the
<TT>PLAYER_SHIP_MOVE(x, y)</TT> event. In the traditional finite state machine
this would be the end of story—the <TT>PLAYER_SHIP_MOVE(x, y)</TT> event would
be silently discarded. However, the state machine in \ref F5s2 "Figure 5-2" has
another layer of the "active" superstate. Per the semantics of state nesting,
this higher-level superstate handles the PLAYER_SHIP_MOVE(x, y) event, which
is exactly what's needed. The same exact argumentation applies for any other
substate of the "active" superstate, such as "flying" or "exploding", because
none of these substates handle the <TT>PLAYER_SHIP_MOVE(x, y)</TT> event.
Instead, the "active" superstate handles the event in one single place,
without repetitions.

\anchor F5s2
\image html Fig1.06.jpg "Figure 5-2 Ship state machine diagram."

\li (1) Upon the initial transition, the Ship state machine enters the "active"
superstate and subscribes to events \c TIME_TICK and \c PLAYER_TRIGGER.

\li (2) At each level of nesting a superstate can have a private initial
transition that designates the active substate after the superstate is entered
directly. Here the initial transition of state "active" designates the
substate "parked" as the initial active substate.

\li (3) The "active" superstate handles the <TT>PLAYER_SHIP_MOVE(x, y)</TT> event
as an internal transition in which it updates the internal data members
<TT>me->x</TT> and <TT>me->y</TT> from the event parameters <TT>e->x</TT> and
<TT>e->y</TT>, respectively.

\li (4) The TAKE_OFF event triggers transition to "flying". This event is
generated by the Tunnel object when the Player starts the game (see the
description of the game in Section \ref lets_play).

\li (5) The entry actions to "flying" include clearing the me->score data member
and posting the event \c SCORE with the event parameter me->score to the
Tunnel active object.

\li (6) The \c TIME_TICK internal transition causes posting the event \c SHIP_IMG
with current Ship position and the \c SHIP_BMP bitmap number to the Tunnel
active object. Additionally, the score is incremented for surviving another
time tick. Finally, when the score is "round" (divisible by 10) it is also
posted to the Tunnel active object. This decimation of the \c SCORE event is
performed just to reduce the bandwidth of the communication, because the
Tunnel active object only needs to give an approximation of the running score
tally to the user.

\li (7) The \c PLAYER_TRIIGGER internal transition causes posting the event
\c MISSILE_FIRE with current Ship position to the Missile active object. The
parameters <TT>(me->x, me->y)</TT> provide the Missile with the initial
position from the Ship.

\li (8) The <TT>DESTROYED_MINE(score)</TT> internal transition causes update of
the score kept by the Ship. The score is not posted to the Table at this
point, because the next \c TIME_TICK will send the "rounded" score, which is
good enough for giving the Player the score approximation.

\li (9) The \c HIT_WALL event triggers transition to "exploding"

\li (10) The <TT>HIT_MINE(type)</TT> event also triggers transition to "exploding"

\li (11) The "exploding" state of the Ship state machine is very similar to the
"exploding" state of Missile (see \ref F5s1 "Figure 5-1"(7-9)).

\li (12) The <TT>TIME_TICK[else]</TT> transition is taken when the Ship finishes
exploding. Upon this transition, the Ship object posts the event
<TT>GAME_OVER(me->score)</TT> to the Tunnel active object to terminate the
game and display the final score to the Player.


\section tunnel 5.3 The Tunnel Active Object

The Tunnel active object has the most complex state machine, which is shown in
\ref F5s3 "Figure 5-3". Unlike the previous state diagrams, the diagram in
\ref F5s3 "Figure 5-3" shows only the high-level of abstraction and omits a lot of
details such as most entry/exit actions, internal transitions, guard
conditions, or actions on transitions. Such a "zoomed out" view is always
legal in the UML, because UML allows you to choose the level of detail that
you want to include in your diagram.

The Tunnel state machine uses state hierarchy more extensively than
the Ship state machine in \ref F5s2 "Figure 5-2". The explanation section
immediately following \ref F5s3 "Figure 5-3" illuminates the new uses of state
nesting as well as the new elements not explained yet in the other state
diagrams.

\anchor F5s3
\image html Fig1.07.jpg "Figure 5-3 Tunnel state machine diagram."

\li (1) An initial transition can target a substate at any level of state
hierarchy, not necessarily just the next-lower level. Here the top-most
initial transition goes down two levels to the substate "demo".

\li (2) The superstate "active" handles the \c PLAYER_QUIT event as a transition
to the final state (see explanation of element (3)). Please note that the
PLAYER_QUIT transition applies to all substates directly or transitively
nested in the "active" superstate. Because a state transition always involves
execution of all exit actions from the states, the high-level PLAYER_QUIT
transition guarantees the proper cleanup that is specific to the current state
context, whichever substate happens to be active at the time when the
\c PLAYER_QUIT event arrives.

\li (3) The final state is indicated in the UML notation as the bull's-eye symbol
and typically indicates destruction of the state machine object. In this case,
the \c PLAYER_QUIT event indicates termination of the game.

\li (4) The <TT>MINE_DISABLED(mine_id)</TT> event is handled at the high level of
the "active" state, which means that this internal transition applies to the
whole sub-machine nested inside the "active" superstate. (See also the
discussion of Mine object in the next section.)

\li (5) The entry action to the "demo" state starts the screen time event (timer)
<TT>me->screenTimeEvt</TT> to expire in 20 seconds. Time events are allocated
by the application, but they are managed by the QF framework. QF provides
functions to arm a time event, such as QTimeEvt_postIn() for one-shot timeout,
and QTimeEvt_postEvery() for periodic time events. Arming a time event is in
effect telling the QF framework, for instance, "Give me a nudge in 20
seconds". QF then posts the time event (the event me->screenTimeEvt in this
case) to the active object after the requested number of clock ticks. Chapters
6 and 7 of \ref PSiCC2 talk about time events in detail.

\li (6) The exit action from the "demo" state disarms the me->screenTimeEvt time
event. This cleanup is necessary when the state can be exited by a different
event than the time event, such as the \c PLAYER_TRIGGER transition.

\li (7) The \c SCREEN_TIMEOUT transition to "screen_saver" is triggered by the
expiration of the me->screenTimeEvt time event. The signal \c SCREEN_TIMEOUT
is assigned to this time event upon initialization and cannot be changed
later.

\li (8) The transition triggered by \c PLAYER_TRIGGER applies equally to the two
substates of the "screen_saver" superstate.


\section mines 5.4 The Mine Components

Mines are also modeled as hierarchical state machines, but are not active
objects. Instead, Mines are components of the Tunnel active object and share
its event queue and priority level. The Tunnel active object communicates with
the Mine components synchronously by directly dispatching events to them via
the function QHsm_dispatch(). Mines communicate with Tunnel and all other
active objects asynchronously by posting events to their event queues via the
function QActive_postFIFO().

\note Active objects exchange events asynchronously, meaning that the sender
of the event merely posts the event to the event queue of the recipient active
object without waiting for the completion of the event processing. In
contrast, synchronous event processing corresponds to a function call (e.g.,
QHsm_dispatch()), which processes the event in the caller's thread of
execution.

\anchor F5s4
\image html Fig1.08.jpg "Figure 5-4 The Table active object manages two types of Mines."

As shown in \ref F5s4 "Figure 5-4", Tunnel maintains the data member mines[],
which is an array of pointers to hierarchical state machines (QHsm *). Each of
these pointers can point either to a Mine1 object, a Mine2 object, or NULL, if
the entry is unused. Please note that Tunnel "knows" the Mines only as generic
state machines (pointers to the QHsm structure defined in QP). Tunnel
dispatches events to Mines uniformly, without differentiating between
different types of Mines. Still, each Mine state machine handles the events it
its specific way. For example, Mine type 2 checks for collision with the
Missile differently than with the Ship while Mine type 1 handles both
identically.

\note The last point is actually very interesting. Dispatching the same event
to different Mine objects results in different behavior, specific to the type
of the Mine, which in OOP is known as polymorphism. I'll have more to say
about this in Chapter 3 of \ref PSiCC2.

Each Mine object is fairly autonomous. The Mine maintains its own position and
is responsible for informing the Tunnel object whenever the Mine gets
destroyed or scrolls out of the display. This information is vital for the
Tunnel object so that it can keep track of the unused Mines.

\ref F5s5 "Figure 5-5" shows a hierarchical state machine of Mine2 state machine.
Mine1 is very similar, except that it uses the same bitmap for testing
collisions with the Missile and the Ship.

\anchor F5s5
\image html Fig1.09.jpg "Figure 5-5 Mine2 state machine diagram."

\li (1) The Mine starts in the "unused" state.

\li (2) The Tunnel object plants a Mine by dispatching the <TT>MINE_PLANT(x,
y)</TT> event to the Mine. The Tunnel provides the <TT>(x, y)</TT> coordinates
as the original position of the Mine.

\li (3) When the Mine scrolls off the display the state
machine transitions to "unused".

\li (4) When the Mine hits the Ship the state machine transitions to "unused".

\li (5) When the Mine scrolls finishes exploding the state machine transitions to
"unused".

\li (6) When the Mine is recycled by the Tunnel object the state machine
transitions to "unused".

\li (7) The exit action in the "unused" state posts the MINE_DISABLDED(mine_id)
event to the Tunnel active object. Through this event, the Mine informs the
Tunnel that it's becoming disabled, so that Tunnel can update its
<TT>mines[]</TT> array (see also \ref F5s4 "Figure 5-4"(4)). The mine_id parameter
of the event becomes the index into the <TT>mines[]</TT> array. Please note
that generating the <TT>MINE_DISABLDED(mine_id)</TT> event in the exit action
from "used" is much safer and more maintainable than repeating this action in
each individual transition (3), (4), (5), and (6).

Prev: \ref design \n
Next: \ref events

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/** \page events 6. Signals, Events, and Active Objects

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref active_objects \n
Next: \ref coding_hsm

In QP-nano, event signals are enumerated just like in the full-version QP. The
only limitation is that signal values in QP-nano cannot exceed 255, because
signals are always represented in a single byte.

In QP-nano, you cannot specify arbitrary event parameters, so you don't derive
events as in full-version QP. Instead, all events in QP-nano are simply
instances of the QEvent structure, which contains the fixed-size scalar
parameter configured according to your definition of Q_PARAM_SIZE (see Listing
\ref L3s2 "Listing 3-2"(2)). On the other hand, active objects in QP-nano are
derived from the QActive base structure, just like they are in the
full-version QP (see \ref derivation). One of the main concerns with respect
to active object structures is to keep them encapsulated. In all QP-nano
examples, including the "Fly 'n' Shoot" game, I demonstrate a technique to
keep the active object structures and state machines completely opaque. I
describe this technique in the explanation section following
\ref L6s1 "Listing 6-1", which shows the header file \c game.h included by all
components of the "Fly 'n' Shoot" application.

\section enumerating 6.1 Enumerating Event Signals and Encapsulating Active Objects

Because events are explicitly shared among most of the application components,
it is convenient to declare them in the separate header file game.h shown
\ref L6s1 "Listing 6-1". The explanation section immediately following the
listing illuminates the interesting points.

\anchor L6s1
<STRONG>Listing 6-1 Signals, event structures, and active object interfaces
defined in file game.h.</STRONG>
\code
 (1) enum GameSignals {                              /* signals used in the game */
 (2)     TIME_TICK_SIG = Q_USER_SIG,                  /* published from tick ISR */
         PLAYER_TRIGGER_SIG, /* published by Player (ISR) to trigger the Missile */
         PLAYER_QUIT_SIG,          /* published by Player (ISR) to quit the game */
         GAME_OVER_SIG,          /* published by Ship when it finishes exploding */
         PLAYER_SHIP_MOVE_SIG,  /* posted by Player (ISR) to the Ship to move it */
         BLINK_TIMEOUT_SIG,           /* signal for Tunnel's blink timeout event */
         SCREEN_TIMEOUT_SIG,         /* signal for Tunnel's screen timeout event */
         TAKE_OFF_SIG,    /* from Tunnel to Ship to grant permission to take off */
         HIT_WALL_SIG,            /* from Tunnel to Ship when Ship hits the wall */
         HIT_MINE_SIG,     /* from Mine to Ship or Missile when it hits the mine */
         SHIP_IMG_SIG,     /* from Ship to the Tunnel to draw and check for hits */
         MISSILE_IMG_SIG,  /* from Missile the Tunnel to draw and check for hits */
         MINE_IMG_SIG,            /* sent by Mine to the Tunnel to draw the mine */
         MISSILE_FIRE_SIG,                /* sent by Ship to the Missile to fire */
         DESTROYED_MINE_SIG, /* from Missile to Ship when Missile destroyed Mine */
         EXPLOSION_SIG,     /* from any exploding object to render the explosion */
         MINE_PLANT_SIG,                  /* from Tunnel to the Mine to plant it */
         MINE_DISABLED_SIG,      /* from Mine to Tunnel when it becomes disabled */
         MINE_RECYCLE_SIG,         /* sent by Tunnel to Mine to recycle the mine */
         SCORE_SIG    /* from Ship to Tunnel to adjust game level based on score */
     };

     /* active objects ..........................................................*/
 (3) extern struct TunnelTag  AO_Tunnel;
 (4) extern struct ShipTag    AO_Ship;
 (5) extern struct MissileTag AO_Missile;

 (6) void Tunnel_ctor (void);
 (7) void Ship_ctor   (void);
 (8) void Missile_ctor(uint8_t speed);

     /* common constants and shared helper functions ............................*/
     . . .
\endcode

\li (1) All signals are defined in one enumeration, which automatically
guarantees the uniqueness of signals.

\li (2) Note that the user signals must start with the offset Q_USER_SIG to
avoid overlapping the reserved QEP-nano signals.

\li (3-5) I declare all active object instances in the system as extern
variables. These declarations are necessary for the initialization of the
\c QF_active[] array (see \ref L3s1 "Listing 3-1"(12)).

\note The active object structures (e.g., <TT>struct TunnelTag</TT>) do not
need to be defined globally in the application header file. The \c QF_active[]
array needs only pointers to the active objects (see 
\ref L3s1 "Listing 3-1"(9-11)), which the compiler can resolve without knowing
the full definition of the active object structure.

I never declare active object structures globally. Instead, I declare the
active object structures in the file scope of the specific active object
module (e.g., <TT>struct TunnelTag</TT> is declared in the \c tunnel.c file
scope). That way, I can be sure that each active object remains fully
encapsulated.

\li (6-8) Every active object in the system must provide a "constructor"
function, which initializes the active object instance. These constructors
don't take the "me" pointers, because they have access to the global active
object instances (see (3-5)). However, the constructors can take some other
initialization parameters. For instance, the \c Missile_ctor() takes the
Missile speed parameter. \ref L3s1 "Listing 3-1"(13-15) shows that the
constructors are called right at the beginning of \c main(). 

\anchor L6s2
<STRONG>Listing 6-2 Generating and posting events from the ISRs
in bsp.c for the ARM-Cortex board.</STRONG>
\code
 (1) static void interrupt ISR_tmr(void) { /* 80x86 enters ISRs with int. locked */

 (2)     QF_tick();                             /* process all armed time events */

 (3)     QActive_postISR((QActive *)&AO_Tunnel,  TIME_TICK_SIG, 0);
 (4)     QActive_postISR((QActive *)&AO_Ship,    TIME_TICK_SIG, 0);
 (5)     QActive_postISR((QActive *)&AO_Missile, TIME_TICK_SIG, 0);

         outp(0x20, 0x20);                        /* write EOI to the master PIC */
     }
     . . .
\endcode

\li (1) Usually, you can use the compiler-generated ISRs with QP-nano. Here, I
use the capability of the Open Watcom compiler to generate ISRs, which are
designated with the extended keyword "interrupt".

\li (2) Just like in the full-version QP, you need to call \c QF_tick() from
the system clock tick ISR.

\li (3-5) QP-nano does not support publishing events. Instead, you post
directly the \c TIME_TICK event to all active objects that need to receive it.

\note QP-nano provides different services for ISRs and different for the task
level. You can only call two QP-nano functions from interrupts: QF_tick() and
QActive_postISR(). Conversely, you should never call these two functions from
the task level. This separation of APIs is closely related to the separate
interrupt locking policies for tasks and interrupts in QP-nano.


Prev: \ref active_objects \n
Next: \ref coding_hsm

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page coding_hsm 7. Coding Hierarchical State Machines

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref events \n
Next: \ref execution

Contrary to widespread misconceptions, you don't need big design automation
tools to translate hierarchical state machines (UML statecharts) into
efficient and highly maintainable C or C++. This section explains how to
hand-code the Ship state machine from \ref F5s2 "Figure 5-2" with QP-nano.
Once you know how to code this state machine, you know how to code them all.

The source code for the Ship state machine is found in the file \c ship.c
located either in the DOS version or the ARM-Cortex version of the "Fly 'n'
Shoot" game. I break the explanation of this file into <STRONG>three</STRONG>
steps.

\section step1 7.1 Step 1: Defining the Ship Structure

In the first step you define the Ship data structure. Just like in case of
events, you use inheritance to derive the Ship structure from the framework
structure QActive (see the sidebar \ref derivation). Creating this inheritance
relationship ties the Ship structure to the QF framework. The main
responsibility of the QActive base structure is to store the information about
the current active state of the state machine, as well as the event queue and
priority level of the Ship active object. In fact, QActive itself derives from
a simpler QEP structure QHsm that represents just the current active state of
a hierarchical state machine. On top of that information, almost every state
machine must also store other "extended-state" information. For example, the
Ship object is responsible for maintaining the Ship position as well as the
score accumulated in the game. You supply this additional information by means
of data members enlisted after the base structure member super, as shown in
\ref L7s1 "Listing 7-1".

\anchor L7s1
<STRONG>Listing 7-1 Deriving the Ship structure in file ship.c.</STRONG>
\code
 (1) #include "qpn_port.h"
 (2) #include "bsp.h"
 (3) #include "game.h"

     /* local objects -----------------------------------------------------------*/
 (4) typedef struct ShipTag {
 (5)     QActive super;                              /* extend the QActive class */
         uint8_t x;
         uint8_t y;
         uint8_t exp_ctr;
         uint16_t score;
     } Ship;                                           /* the Ship active object */

 (6) static QState Ship_initial  (Ship *me);
 (7) static QState Ship_active   (Ship *me);
     static QState Ship_parked   (Ship *me);
     static QState Ship_flying   (Ship *me);
     static QState Ship_exploding(Ship *me);

     /* global objects ----------------------------------------------------------*/
 (8) Ship AO_Ship;
\endcode



\li (1) Every application-level C-file that uses the QP platform must include the
\c qp_port.h header file.

\li (2) The \c bsp.h header file contains the interface to the
Board Support Package.

\li (3) The \c game.h header file contains the declarations of
events and other facilities shared among the components of the application
\li (see \ref L6s1 "Listing 6-1").

\li (4) This structure defines the Ship active object.

\li (5) The Ship active object structure derives from the framework structure
QActive, as described in Section \derivation.

\li (6) The \c Ship_initial() function defines the top-most initial transition
in the Ship state machine. The initial pseudostate handler has signature
identical to the regular state handler function.

\li (7) The state-handler functions in QP-nano also don't take the event
parameter. (In QP-nano, the current event is embedded in the state machine.)
As in the full-version QP, a state handler function in QP-nano returns a
pointer the superstate handler function.

\note I use a simple naming convention to strengthen the association between
the structures and the functions designed to operate on these structures.
First, I name the functions by combining the typedef'ed structure name with
the name of the operation (e.g., \c Ship_active). Second, I always place the
pointer to the structure as the first argument of the associated function and
I always name this argument <TT>me</TT> (e.g., <TT>Ship_active(Ship *me,
...)</TT>).

\li (8) In this line I allocate the global \c AO_Ship active object. Please
note that actual structure definition for the Ship active object is accessible
only locally at the file scope of the \c ship.c file.

\note QP-nano assumes that all global or static variables without explicit
initialization value are initialized to zero upon the system startup, which is
a requirement of the ANSI-C standard. You should make sure that your startup
code clears the static variables data section (a.k.a. Block Started by Symbol
section or BSS) before calling \c main().


\section step2 7.2 Step 2: Initializing the State Machine

The state machine initialization is divided into the following two steps for
increased flexibility and better control of the initialization timeline:

-# The state machine "constructor"; and
-# The top-most initial transition.

The state machine "constructor", such as \c Ship_ctor(), intentionally does
not execute the top-most initial transition defined in the initial pseudostate
because at that time some vital objects can be missing and critical hardware
might not be properly initialized yet3. Instead, the state machine
"constructor" merely puts the state machine in the initial pseudostate. Later,
the user code must trigger the top-most initial transition explicitly, which
happens actually inside the function QActive_start() (see 
\ref L3s1 "Listing 3-11"(18-20)). \ref L7s2 "Listing 7-2" shows the instantiation
(the "constructor" function) and initialization (the initial pseudostate) of
the Ship active object.

\anchor L7s2
<STRONG>Listing 7-2 Instantiation and Initialization of the Ship active object
in ship.c.</STRONG>
\code
 (1) void Ship_ctor(void) {
 (2)     Ship *me = &AO_Ship;
 (3)     QActive_ctor(&me->super, (QStateHandler)&Ship_initial);
 (4)     me->x = GAME_SHIP_X;
 (5)     me->y = GAME_SHIP_Y;
     }

     /* HSM definition ----------------------------------------------------------*/
 (6) QState Ship_initial(Ship *me) {
 (7)     return Q_TRAN(&Ship_active);             /* top-most initial transition */
     }
\endcode

\li (1) The global function Ship_ctor() is prototyped in game.h and called at the
beginning of main().

\li (2) The "me" pointer points to the statically allocated Ship object (see
\ref L7s1 "Listing 7-1"(6)).

\li (3) Every derived structure is responsible for initializing the part inherited
from the base structure. The "constructor" QActive_ctor() puts the state
machine in the initial pseudostate &Ship_initial. (see 
\ref L6s1 "Listing 6-1"(5)).

\li (4-5) The Ship position is initialized.

\li (6) The Ship_initial() function defines the top-most initial transition in
the Ship state machine (see \ref F5s2 "Figure 5-2"(1)).

\li (7) The initial state "active" is specified by invoking the QEP-nano macro
#Q_TRAN().


\section step3 7.3 Step 3: Defining State Handler Functions

In the last step, you actually code the Ship state machine by implementing one
state at a time as a state handler function. To determine what elements belong
the any given state handler function, you follow around the state's boundary
in the diagram (\ref F5s2 "Figure 5-2"). You need to implement all transitions
originating at the boundary, any entry and exit actions defined in the state,
as well as all internal transitions enlisted directly in the state.
Additionally, if there is an initial transition embedded directly in the
state, you need to implement it as well.

Take for example the state "flying" shown in \ref F5s2 "Figure 5-2". This state
has an entry action and two transitions originating at its boundary:
\c HIT_WALL and <TT>HIT_MINE(type)</TT>, as well as three internal transitions
\c TIME_TICK, \c PLAYER_TRIGGER, and <TT>DESTROYED_MINE(score)</TT>. The
"flying" state nests inside the "active" superstate. \ref L7s3 "Listing 7-3"
shows two state handler functions of the Ship state machine from
\ref F5s2 "Figure 5-2". The state handler functions correspond to the states
"active" and "flying", respectively. The explanation section immediately
following the listing highlights the important implementation techniques.

\anchor L7s3
<STRONG>Listing 7-3 State handler functions for states "active" and "flying"
in ship.c.</STRONG>
\code
     QState Ship_active(Ship *me) {
 (1)     switch (Q_SIG(me)) {
             case Q_INIT_SIG: {                     /* nested initial transition */
 (2)             return Q_TRAN(&Ship_parked);
             }
             case PLAYER_SHIP_MOVE_SIG: {
 (3)             me->x = (uint8_t)Q_PAR(me);
 (4)             me->y = (uint8_t)(Q_PAR(me) >> 8);
 (5)             return Q_HANDLED();
             }
         }
 (6)     return Q_SUPER(&QHsm_top);
     }
     /*..........................................................................*/
     QState Ship_flying(Ship *me) {
         switch (Q_SIG(me)) {
             case Q_ENTRY_SIG: {
                 me->score = 0;                               /* reset the score */
 (7)             QActive_post((QActive *)&AO_Tunnel, SCORE_SIG, me->score);
                 return Q_HANDLED();
             }
             case TIME_TICK_SIG: {
                 /* tell the Tunnel to draw the Ship and test for hits */
 (8)             QActive_post((QActive *)&AO_Tunnel, SHIP_IMG_SIG,
                              ((QParam)SHIP_BMP << 16)
                              | (QParam)me->x
                              | ((QParam)me->y << 8));

                 ++me->score;  /* increment the score for surviving another tick */
                 if ((me->score % 10) == 0) {           /* is the score "round"? */
                     QActive_post((QActive *)&AO_Tunnel, SCORE_SIG, me->score);
                 }
                 return Q_HANDLED();
             }
             case PLAYER_TRIGGER_SIG: {                   /* trigger the Missile */
                 QActive_post((QActive *)&AO_Missile, MISSILE_FIRE_SIG,
                              (QParam)me->x
                              | (((QParam)me->y + SHIP_HEIGHT - 1) << 8));
                 return Q_HANDLED();
             }
             case DESTROYED_MINE_SIG: {
                 me->score += Q_PAR(me);
                 /* the score will be sent to the Tunnel by the next TIME_TICK */
                 return Q_HANDLED();
             }
             case HIT_WALL_SIG:
             case HIT_MINE_SIG: {
 (9)             return Q_TRAN(&Ship_exploding);
             }
         }
(10)     return Q_SUPER(&Ship_active);
     }
\endcode

\li (1) Every state handler is structured as a switch statement that
discriminates based on the signal of the event, which in QP-nano is obtained
by the macro #Q_SIG(me).

\li (2) You designate the target of a nested initial transition with the
#Q_TRAN() macro.

\note The macro #Q_TRAN() must always follow the return statement.

\li (3-4) You access the data members of the Ship state machine via the "me"
parameter of the state handler function. You access the event parameters via
the Q_PAR(me) macro. Please note that in this case actually two logical event
parameters are e from the scalar QP-nano parameter. The x coordinate of the
Ship is sent in the least-significant byte, and the y coordinate in the next
byte.

\note Each event can have as many event parameters as you can squeeze into the
available bits.

\li (5) You terminate the case statement with <TT>return Q_HANDLED()</TT>,
which informs QEP-nano that the initial transition has been handled.

\li (6) The final \c return from a state handler function designates the
superstate of that state, which is exactly the same as in the full-version QP.
QEP-nano provides the "top" state as a state handler function QHsm_top(), and
therefore the \c Ship_active() state handler returns the pointer &QHsm_top.
(see the Ship state diagram in \ref F5s2 "Figure 5-2")

\li (7) The function QActive_post() posts the specified event signal and
parameter directly to the recipient active object. Direct event posting is the
only event delivery mechanism supported in QP-nano.

\note You use QActive_post() function at the task-level. You should
<STRONG>never</STRONG> call QActive_postISR() from the task-level.

\li (8) The event posting demonstrates how to combine several logical event
parameters into the single scalar parameter managed by QP-nano. Of course, you
must be careful not to overflow the dynamic range of the QP-nano parameter
configured with the #Q_PARAM_SIZE macro (see \ref L3s2 "Listing 3-2"(1)).

\li (9) You designate the target of a transition with the #Q_TRAN() macro.

\li (10) The state "flying" (see \ref F5s2 "Figure 5-2") nests in the state
"active", so the state handler \c Ship_flying() returns the pointer \c
&Ship_active.

When implementing state handler functions you need to keep in mind that the
QEP-nano event processor is in charge here rather than your code. QEP-nano
will invoke a state handler function for various reasons: for hierarchical
event processing, for execution of entry and exit actions, for triggering
initial transitions, or even just to elicit the superstate of a given state
handler. Therefore, you should not assume that a state handler would be
invoked only for processing signals enlisted in the case statements. You
should avoid any code outside the switch statement, especially code that would
have side effects.

Prev: \ref events \n
Next: \ref execution

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page execution 8. Using the Built-in Real-Time Kernels

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref coding_hsm \n
Next: \ref code_size

As you saw in \ref L3s1 "Listing 3-1"(17), the \c main() function eventually
gives control to the QF-nano framework by calling QF_run() to execute the
application. In this section, I briefly explain how QF-nano allocates the CPU
cycles to various tasks within the system and what options you have in
choosing the execution model.

\section using_vanilla 8.1 Simple Non-Preemptive "Vanilla" Kernel

In the simplest configuration, the "Fly 'n' Shoot" game executes under the
simple cooperative "vanilla" kernel, which is provided in the QP-nano. The
"vanilla" kernel operates by constantly polling all event queues of active
objects in an endless loop. The kernel always selects the highest-priority
active object ready to run, which is the highest-priority active object with a
non-empty event queue.

\note The "vanilla" kernel is so simple that many commercial real-time
frameworks don't even call it a kernel . Instead, this configuration is simply
referred to as "without an RTOS". However, if you want to understand what it
means to execute active objects "without an RTOS" and what execution profile
you can expect in this case, you need to realize that a simple cooperative
vanilla kernel is indeed involved.

The interrupt service routines (ISRs) can preempt the execution of active
objects at any time, but due to the simplistic nature of the "vanilla" kernel,
every ISR returns to exactly the preemption point. If the ISR posts or
publishes an event to any active object, the processing of this event won't
start until the current RTC step completes. The maximum time an event for the
highest-priority active object can be delayed this way is called the
task-level response. With the non-preemptive "vanilla" kernel, the task-level
response is equal to the longest RTC step of all active objects in the system.
Please note that the task-level response of the "vanilla" kernel is still a
lot better than the traditional "superloop" (a.k.a., main+ISRs) architecture.
I'll have more to say about this in the upcoming Section \ref comparison,
where I compare the event-driven "Fly 'n' Shoot" example to the traditionally
structured "Quickstart" application.

The task-level response of the simple "vanilla" kernel turns out to be
adequate for surprisingly many applications, because state machines by nature
handle events quickly without a need to busy-wait for events. (A state machine
simply runs-to-completion and becomes dormant until another event arrives).
Please also note that often you can make the task-level response as fast as
you need by breaking up longer RTC steps into shorter ones (e.g., by using the
"Reminder" state pattern described in Chapter 5 of \ref PSiCC2.

\section using_QK 8.2 The QK-nano Preemptive Kernel

In some cases, breaking up long RTC steps into short enough pieces might be
very difficult, and consequently the task-level response of the non-preemptive
"vanilla" kernel might be too long. An example system could be a GPS receiver.
Such a receiver performs a lot of floating point number crunching on a
fixed-point CPU to calculate the GPS position. At the same time, the GPS
receiver must track the GPS satellite signals, which involves closing control
loops in sub-millisecond intervals. It turns out that it's not easy to break
up the position-fix computation into short enough RTC steps to allow reliable
signal tracking. But the RTC semantics of state machine execution does not
mean that a state machine has to monopolize the CPU for the duration of the
RTC step. A preemptive kernel can perform a context switch in the middle of
the long RTC step to allow a higher-priority active object to run. As long as
the active objects don't share resources they can run concurrently and
complete their RTC steps independently.

The QP-nano event-driven platform includes a tiny, fully preemptive,
priority-based real-time kernel component called QK-nano, which is
specifically designed for processing events in the RTC fashion. Configuring
QP-nano to use the preemptive QK-nano kernel is very easy, but as with any
fully preemptive kernel you must be very careful with any resources shared
among active objects5. The "Fly 'n' Shoot" example has been purposely designed
to avoid any resource sharing among active objects, so the application code
does not need to change at all to run on top of the QK-nano preemptive kerel,
or any other preemptive kernel or RTOS for that matter. The accompanying code
contains the "Fly 'n' Shoot" example with QK in the following directory:
&lt;qpn&gt;\\examples\\80x86\\watcom\\game-qk\\. You can execute this example
in a DOS-console on any standard Windows-based PC.


Prev: \ref coding_hsm \n
Next: \ref code_size

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/** \page code_size 9. QP-nano Memory Usage

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref execution \n
Next: \ref comparison

To give you an idea of the QP-nano memory usage, \ref T10s1 "Table 10-1" and
\ref T10s2 "10-2" show the memory footprint of the QP-nano components for
various settings of the configuration macros. The data for
\ref T10s1 "Table 10-1" has been obtained from the IAR
compiler for MSP430 v4.10A (the KickStart edition), while data for
\ref T10s2 "Table 10-2" has been obtained from the IAR compiler for
ARM-Cortex v5.40 (also the KickStart edition). In both cases I have
selected optimization level High/Size. The first column of 
\ref T10s1 "Table 10-1" and \ref T10s2 "10-2" lists the configuration
macros that are significant for the RAM or ROM usage in QP-nano. I have
omitted the #QF_ISR_NEST and #QF_ISR_KEY_TYPE macros, as they have virtually
no impact on the code or data sizes shown in the tables (even though, defining
#QF_ISR_KEY_TYPE increases somewhat the stack usage.)  Both MSP430 and
ARM-Cortex offer good code density and the IAR compiler generates fantastic
machine code for these CPU architectures. (I've seen much worse results for
older CPU architectures, such as 8051 or the PIC). Therefore, you should treat
the data in \ref T10s1 "Table 10-1" and \ref T10s2 "10-2" as minimum memory
footprint of QP-nano rather than average results. The intent of 
\ref T10s1 "Table 10-1" is primarily to give you a general idea for the
<STRONG>relative</STRONG> cost of various options, rather than to provide
you absolutely accurate measurements.

\note The \ref T10s1 "Table 10-1" and \ref T10s2 "10-2" show only the memory
used directly by the QP-nano components, but do not include the memory
required by the application. In particular, you don't see the stack usage,
or the RAM required by active objects and their event queues.

\anchor T10s1
\image html Tab12.01.jpg "Table 10-1 QP-nano memory usage in bytes for various settings of the configuration parameters (MSP430/IAR compiler/optimization-High/Size)"

\anchor T10s2
\image html Tab12.02.jpg "Table 10-2  QP-nano memory usage in bytes for various settings of the configuration parameters (ARM-Cortex/IAR compiler/optimization-High/Size)"

The various QP-nano configurations are listed in \ref T10s1 "Table 10-1" and
\ref T10s2 "10-2" separately for the non-preemptive "vanilla" kernel
(configurations 1-6) and the preemptive QK-nano kernel (configurations 7-12).
Within each group, the simpler configurations come before the more expensive
ones. For example, the absolutely minimal configuration number 1 eliminates
the HSM code (so only basic FSM support is provided), uses no event
parameters, no time events, and up to 4 active objects. This minimal
configuration is clearly very limited. However, the configuration number 4 is
already quite reasonable. It still offers only non-hierarchical FSMs, but
includes event parameter, time events, and up to 8 active objects, at the cost
of less than 700 bytes of code space. By far, the most expensive feature (in
terms of ROM) is the HSM support, which costs about 650 bytes (e.g., compare
configurations number 4 and 5 or 10 and 11). On the other hand, the QK-nano
preemptive kernel increases the ROM footprint only by 50-100 bytes compared
to the "vanilla" kernel. Obviously, the true cost of QK-nano lies in the
increased stack requirements, which \ref T10s1 "Table 10-1" and
\ref T10s2 "10-2" don't show.


Prev: \ref execution \n
Next: \ref comparison

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/** \page comparison 10. Comparison to the Traditional Approach

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref code_size \n
Next: \ref summary

The "Fly 'n' Shoot" game behaves intentionally almost identically to the
"Quickstart" application provided in source code with the Luminary Micro
ARM Cortex-M3 LM3S811 evaluation kit (http://www.luminarymicro.com). In this
section I'd like to compare the traditional approach represented by the
"Quickstart" application with the event-driven solution exemplified in
the "Fly 'n' Shoot" game.

\ref F10s1 "Figure 10-1"(a) shows schematically the flowchart of the
"Quickstart" application, while \ref F10s1 "Figure 10-1"(b) shows the
flowchart of the "Fly 'n' Shoot" game running on top of the cooperative
"vanilla" kernel. At the highest level, the flowcharts are similar in that
they both consist of an endless loop surrounding the entire processing. But
the internal structure of the main loop is very different in the two cases. As
indicated by the heavy lines in the flowcharts, the "Quickstart" application
spends most of its time in the tight "event loops" designed to busy-wait for
certain events, such as the screen update event. In contrast, the "Fly 'n'
Shoot" application spends most of its time right in the main loop. The QP-nano
framework dispatches any available event to the appropriate state machine that
handles the event and returns quickly to the main loop without ever waiting
for events internally.

\anchor F10s1
\image html Fig1.11.jpg "Figure 10-1 The control flow in the "Quickstart" application (a), and the Fly 'n' Shoot example (b). The heavy lines represent the most frequently exercised paths through the code."

The "Quickstart" application has much more convoluted flow of control than the
"Fly 'n' Shoot" example, because the traditional solution is very specific to
the problem at hand while the event-driven approach is generic. The
"Quickstart" application is structured very much like a traditional sequential
program that tries to stay in control from the beginning to the end. From time
to time, the application pauses to busy-wait for a certain event, whereas the
code is generally not ready to handle any other events than the one it chooses
to wait for. All this contributes to the inflexibility of the design. Adding
new events is hard because the whole structure of the intervening code is
designed to accept only very specific events and would need to change
dramatically to accommodate new events. Also, while busy-waiting for the
screen update event (equivalent to the \c TIME_TICK event in "Fly 'n' Shoot"
example) the application is really not responsive to any other events. The
task-level response is hard to characterize and generally depends on the event
type. The timing established by the hard-coded waiting for the existing events
might not work well for new events.

In contrast, the event-driven "Fly 'n' Shoot" application has a much simpler
control flow that is purely event-driven and completely generic (see
\ref F10s1 "Figure 10-1"(b)). The context of each active object component is
represented as the current state of a state machine, rather than as a certain
place in the code. That way, hanging in tight "event loops" around certain
locations in the code corresponding to the current context is unnecessary.
Instead, a state machine remembers the context very efficiently as a small
data item (the state-variable, see Chapter 3 of \ref PSiCC2). After processing
of each event the state machine can return to the common event loop that is
designed generically to handle all kinds of events. For every event, the state
machine naturally picks up where it left off and moves on to the next state,
if necessary. Adding new events is easy in this design, because a state
machine is responsive to any event at any time. An event-driven,
state-machine-based application is incomparably more flexible and resilient to
change than the traditional one.

\note The generic event loop can also very easily detect the situation when no
events are available, in which case the QP-nano framework calls the QF_onIdle()
function (see \ref F10s1 "Figure 10-1"(b)). This callback function is designed
to be customized by the application and is the ideal place to put the CPU in a
<STRONG>low-power sleep mode</STRONG> to conserve the power. In contrast, the
traditional approach does not offer any single place to transition to the
low-power sleep mode, and consequently is much less friendly for implementing
truly low-power designs.


Prev: \ref code_size \n
Next: \ref summary

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/** \page summary 11. Summary

<I>This QP-nano Tutorial is adapted from Chapter 1 of \ref PSiCC2\n
by Miro Samek, the founder and president of Quantum Leaps, LLC.</I>

\image html qp_tutorial.jpg

Prev: \ref comparison

If you've never done event-driven programming before, the internal structure
of the "Fly 'n' Shoot" game must certainly represent a big paradigm shift for
you. In fact, I hope that it actually blows your mind, because otherwise I'm
not sure that you really appreciate the complete reversal of control of an
event-driven program compared to the traditional sequential code. This
reversal of control, known as the "Hollywood Principle" (don't call us, we'll
call you), baffles many newcomers, who often find it "mind-boggling",
"backwards", or "weird".

My main goal in this Tutorial was just to introduce you to the event-driven
paradigm and the modern state machines to convince you that these powerful
concepts aren't particularly hard to implement directly in C or C++. Indeed, I
hope you noticed that the actual coding of the nontrivial "Fly 'n' Shoot" game
wasn't a big deal at all. All you needed to know was just a few cookie-cutter
rules for coding state machines and familiarity with a few framework services
for implementing the actions.

Wile the coding turned out to be essentially a non-issue; the bulk of the
programming effort was spent on the design of the application. At this point,
I hope that the "Fly 'n' Shoot" example helps you to get the big picture of
how the method works. Under the event driven model, the program structure is
divided into two rough groups: events and state machine components (active
objects). An event represents the occurrence of something interesting. A state
machine codifies the reactions to the events, which generally depend both on
the nature of the event and on the state of the component. While events often
originate from the outside of your program, such as time ticks or button
presses in the "Fly 'n' Shoot" game, events can also be generated internally
by the program itself. For example the Mine components generate notification
events when they detect a collision with the Missile or the Ship.

An event-driven program executes by constantly checking for possible events
and, when an event is detected, dispatching the event to the appropriate state
machine component (see \ref F10s1 "Figure 10-1"(b)). In order for this
approach to work, the events must be checked continuously and frequently. This
implies that the state machines must execute quickly, so that the program can
get back to checking for events. In order to meet this requirement, a state
machine cannot go into a condition where it is busy-waiting for some long or
indeterminate time. The most common example of this would be a while loop
inside a state-handler function, where the condition for termination was not
under program control, for instance the button press. This kind of program
structure, an indefinite loop, is referred to as "blocking" code6, and you saw
examples of it in the "Quickstart" application (see
\ref F10s1 "Figure 10-1"(a)). In order for the event driven programming model
to work, you must only write "non-blocking" code.

Finally, the "Fly 'n' Shoot" example demonstrates the use of the event-driven
platform called QP-nano, which is a collection of components for building
event-driven application. The QF-nano real-time framework component framework
embodies the "Hollywood principle", by calling the application code, not the
other way around. Such arrangement is very typical for event-driven systems
and application frameworks similar to QF-nano are at the heart of virtually
every design automation tool on the market today.

The QP-nano event-driven platform scales down better and than any traditional
RTOS or real-time kernel. In fact, you can view QP-nano as a high-level,
event-driven, real-time operating system for tiny, low-end embedded systems.


Prev: \ref comparison

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/

/**
\page derivation Encapsulation and Single Inheritance in C

Inheritance is the ability to derive new structures based on existing
structures in order to reuse and organize code. You can implement single
inheritance in C very simply by literally embedding the base structure as the
first member of the derived structure. For example, \ref FA1 "Figure 1"(a)
shows the structure ScoreEvt derived from the base structure QEvent by
embedding the QEvent instance as the first member of ScoreEvt. To make this
idiom better stand out, I always name the base structure member super.

\anchor FA1 \image html FA1.jpg "Figure 1 (a) Derivation of structures in C, (b) memory alignment, and (c) the UML class diagram."

As shown in \ref FA1 "Figure 1"(b), such nesting of structures always aligns
the data member super at the beginning of every instance of the derived
structure. In particular, this alignment lets you treat a pointer to the
derived ScoreEvt structure as a pointer to the QEvent base structure.
Consequently, you can always safely pass a pointer to ScoreEvt to any C
function that expects a pointer to QEvent. (To be strictly correct in C, you
should explicitly cast this pointer. In OOP such casting is called upcasting
and is always safe.) Therefore, all functions designed for the QEvent
structure are automatically available to the ScoreEvt structure as well as
other structures derived from QEvent. \ref FA1 "Figure 1"(c) shows the UML
class diagram depicting the inheritance relationship between ScoreEvt and
QEvent structures.

QP uses single inheritance quite extensively not just for derivation of events
with parameters, but also for derivation of state machines and active objects.
Of course, the C++ version of QP uses the native C++ support for class
inheritance rather than "derivation of structures".

\image html logo_ql_TM.jpg
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.\n
http://www.quantum-leaps.com
*/
