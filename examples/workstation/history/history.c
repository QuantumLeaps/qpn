/*.$file${.::history.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: history.qm
* File:  ${.::history.c}
*
* This code has been generated by QM 5.0.0 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::history.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpn.h"     /* QP-nano */
#include "bsp.h"     /* Board Support Package */
#include "history.h" /* Application interface */

#include "safe_std.h" /* portable "safe" <stdio.h>/<string.h> facilities */
#include <stdlib.h>

//Q_DEFINE_THIS_FILE

/*.$declare${SMs::ToastOven} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${SMs::ToastOven} .......................................................*/
typedef struct ToastOven {
/* protected: */
    QHsm super;

/* private state histories */
    QStateHandler hist_doorClosed;
} ToastOven;

/* protected: */
static QState ToastOven_initial(ToastOven * const me);
static QState ToastOven_doorClosed(ToastOven * const me);
static QState ToastOven_heating(ToastOven * const me);
static QState ToastOven_toasting(ToastOven * const me);
static QState ToastOven_baking(ToastOven * const me);
static QState ToastOven_off(ToastOven * const me);
static QState ToastOven_doorOpen(ToastOven * const me);
static QState ToastOven_final(ToastOven * const me);
/*.$enddecl${SMs::ToastOven} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static ToastOven l_oven; /* the only instance of the ToastOven class */

/* global-scope definitions -----------------------------------------*/
QHsm * const the_oven = (QHsm *)&l_oven; /* the opaque pointer */

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 670U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.7.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${SMs::ToastOven_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${SMs::ToastOven_ctor} ..................................................*/
void ToastOven_ctor(void) {
    ToastOven *me = &l_oven;
    QHsm_ctor(&me->super, Q_STATE_CAST(&ToastOven_initial));
}
/*.$enddef${SMs::ToastOven_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${SMs::ToastOven} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${SMs::ToastOven} .......................................................*/
/*.${SMs::ToastOven::SM} ...................................................*/
static QState ToastOven_initial(ToastOven * const me) {
    /*.${SMs::ToastOven::SM::initial} */
    /* state history attributes */
    /* state history attributes */
    me->hist_doorClosed = Q_STATE_CAST(&ToastOven_off);
    return Q_TRAN(&ToastOven_doorClosed);
}
/*.${SMs::ToastOven::SM::doorClosed} .......................................*/
static QState ToastOven_doorClosed(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorClosed} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "door-Closed");
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_doorClosed = QHsm_state(me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&ToastOven_off);
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::TERMINATE} */
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&ToastOven_final);
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::OPEN} */
        case OPEN_SIG: {
            status_ = Q_TRAN(&ToastOven_doorOpen);
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::TOAST} */
        case TOAST_SIG: {
            status_ = Q_TRAN(&ToastOven_toasting);
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::BAKE} */
        case BAKE_SIG: {
            status_ = Q_TRAN(&ToastOven_baking);
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::OFF} */
        case OFF_SIG: {
            status_ = Q_TRAN(&ToastOven_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::doorClosed::heating} ..............................*/
static QState ToastOven_heating(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorClosed::heating} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "heater-On");
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::heating} */
        case Q_EXIT_SIG: {
            PRINTF_S("%s;", "heater-Off");
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorClosed::heating::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&ToastOven_toasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&ToastOven_doorClosed);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::doorClosed::heating::toasting} ....................*/
static QState ToastOven_toasting(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorClosed::heating::toasting} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "toasting");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&ToastOven_heating);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::doorClosed::heating::baking} ......................*/
static QState ToastOven_baking(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorClosed::heating::baking} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "baking");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&ToastOven_heating);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::doorClosed::off} ..................................*/
static QState ToastOven_off(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorClosed::off} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "toaster-Off");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&ToastOven_doorClosed);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::doorOpen} .........................................*/
static QState ToastOven_doorOpen(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::doorOpen} */
        case Q_ENTRY_SIG: {
            PRINTF_S("%s;", "door-Open,lamp-On");
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorOpen} */
        case Q_EXIT_SIG: {
            PRINTF_S("%s;", "lamp-Off");
            status_ = Q_HANDLED();
            break;
        }
        /*.${SMs::ToastOven::SM::doorOpen::CLOSE} */
        case CLOSE_SIG: {
            status_ = Q_TRAN_HIST(me->hist_doorClosed);
            break;
        }
        /*.${SMs::ToastOven::SM::doorOpen::TERMINATE} */
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&ToastOven_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${SMs::ToastOven::SM::final} ............................................*/
static QState ToastOven_final(ToastOven * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${SMs::ToastOven::SM::final} */
        case Q_ENTRY_SIG: {
            BSP_exit(); /* terminate the application */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${SMs::ToastOven} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
